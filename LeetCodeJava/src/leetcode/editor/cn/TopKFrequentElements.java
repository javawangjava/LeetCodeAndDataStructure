/**
 * <p>ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ <code>nums</code> å’Œä¸€ä¸ªæ•´æ•° <code>k</code> ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ <code>k</code> é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ <strong>ä»»æ„é¡ºåº</strong>
 * è¿”å›ç­”æ¡ˆã€‚</p>
 *
 * <p> </p>
 *
 * <p><strong>ç¤ºä¾‹ 1:</strong></p>
 *
 * <pre>
 * <strong>è¾“å…¥: </strong>nums = [1,1,1,2,2,3], k = 2
 * <strong>è¾“å‡º: </strong>[1,2]
 * </pre>
 *
 * <p><strong>ç¤ºä¾‹ 2:</strong></p>
 *
 * <pre>
 * <strong>è¾“å…¥: </strong>nums = [1], k = 1
 * <strong>è¾“å‡º: </strong>[1]</pre>
 *
 * <p> </p>
 *
 * <p><strong>æç¤ºï¼š</strong></p>
 *
 * <ul>
 * <li><code>1 <= nums.length <= 10<sup>5</sup></code></li>
 * <li><code>k</code> çš„å–å€¼èŒƒå›´æ˜¯ <code>[1, æ•°ç»„ä¸­ä¸ç›¸åŒçš„å…ƒç´ çš„ä¸ªæ•°]</code></li>
 * <li>é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå”¯ä¸€ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°ç»„ä¸­å‰ <code>k</code> ä¸ªé«˜é¢‘å…ƒç´ çš„é›†åˆæ˜¯å”¯ä¸€çš„</li>
 * </ul>
 *
 * <p> </p>
 *
 * <p><strong>è¿›é˜¶ï¼š</strong>ä½ æ‰€è®¾è®¡ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ <strong>å¿…é¡»</strong> ä¼˜äº <code>O(n log n)</code> ï¼Œå…¶ä¸­ <code>n</code><em>
 *
 * </em>æ˜¯æ•°ç»„å¤§å°ã€‚</p>
 * <div><div>Related Topics</div><div><li>æ•°ç»„</li><li>å“ˆå¸Œè¡¨</li><li>åˆ†æ²»</li><li>æ¡¶æ’åº</li><li>è®¡æ•°</li><li>å¿«é€Ÿé€‰æ‹©</li><li
 * >æ’åº</li><li>å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰</li></div></div><br><div><li>ğŸ‘ 1251</li><li>ğŸ‘ 0</li></div>
 */

package leetcode.editor.cn;

import java.util.*;

/**
 * 347
 * å‰ K ä¸ªé«˜é¢‘å…ƒç´ 
 * @author wangweizhou
 * @date 2022-07-06 18:15:51
 */


public class TopKFrequentElements {
    public static void main(String[] args) {
        //æµ‹è¯•ä»£ç 
        Solution solution = new TopKFrequentElements().new Solution();

        int[] nums = {1, 2, 2, 1, 3, 1};
        int[] ans = solution.topKFrequent(nums, 2);

    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {


        // è¿™ä¸ªé¢˜ç›®çš„è¾“å…¥æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå“ˆå¸Œè¡¨å¯ä»¥ç”¨æ¥ç»Ÿè®¡æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„é¢‘ç‡ï¼Œå“ˆå¸Œè¡¨çš„é”®æ˜¯æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—ï¼Œè€Œå€¼æ˜¯æ•°å­—å‡ºç°çš„é¢‘ç‡ã€‚
        // æ¥ä¸‹æ¥æ‰¾å‡ºå‡ºç°é¢‘ç‡æœ€é«˜çš„kä¸ªæ•°å­—ã€‚å¯ä»¥ç”¨ä¸€ä¸ªæœ€å°å †å­˜å‚¨é¢‘ç‡æœ€é«˜çš„kä¸ªæ•°å­—ï¼Œå †ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯æ•°ç»„ä¸­çš„æ•°å­—åŠå…¶åœ¨æ•°ç»„ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚
        // ç”±äºæ¯”è¾ƒçš„æ˜¯æ•°å­—çš„é¢‘ç‡ï¼Œå› æ­¤è®¾ç½®æœ€å°å †æ¯”è¾ƒå…ƒç´ çš„è§„åˆ™ï¼Œä»¥ä¾¿è®©é¢‘ç‡æœ€ä½çš„æ•°å­—ä½äºå †çš„é¡¶éƒ¨ã€‚
        // åœ¨ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡å®Œæ•°ç»„ä¸­æ¯ä¸ªæ•°å­—çš„é¢‘ç‡ä¹‹åï¼Œå†é€ä¸€æ‰«æå“ˆå¸Œè¡¨ä¸­æ¯ä¸ªä»æ•°å­—åˆ°é¢‘ç‡çš„æ˜ å°„ï¼Œä»¥ä¾¿æ‰¾å‡ºé¢‘ç‡æœ€é«˜çš„kä¸ªæ•°å­—ã€‚
        // å¦‚æœæœ€å°å †ä¸­å…ƒç´ çš„æ•°ç›®å°äºkï¼Œåˆ™ç›´æ¥å°†ä»æ•°å­—åˆ°é¢‘ç‡çš„æ˜ å°„æ·»åŠ åˆ°æœ€å°å †ä¸­ã€‚
        // å¦‚æœæœ€å°å †ä¸­å·²ç»æœ‰kä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæ¯”è¾ƒå¾…æ·»åŠ æ•°å­—çš„é¢‘ç‡å’Œä½äºå †é¡¶çš„æ•°å­—çš„é¢‘ç‡ã€‚
        // å¦‚æœå¾…æ·»åŠ çš„æ•°å­—çš„é¢‘ç‡ä½äºæˆ–ç­‰äºå †é¡¶çš„æ•°å­—çš„é¢‘ç‡ï¼Œé‚£ä¹ˆå †ä¸­çš„kä¸ªæ•°å­—çš„é¢‘ç‡éƒ½æ¯”å¾…æ·»åŠ çš„æ•°å­—çš„é¢‘ç‡é«˜ï¼Œå®ƒä¸å¯èƒ½æ˜¯kä¸ªé¢‘ç‡æœ€é«˜çš„æ•°å­—ä¸­çš„ä¸€ä¸ªï¼Œå¯ä»¥å¿½ç•¥ã€‚
        // å¦‚æœå¾…æ·»åŠ çš„æ•°å­—çš„é¢‘ç‡é«˜äºå †é¡¶çš„æ•°å­—çš„é¢‘ç‡ï¼Œé‚£ä¹ˆåˆ é™¤å †é¡¶çš„æ•°å­—ï¼ˆæœ€å°å †ä¸­é¢‘ç‡æœ€ä½çš„æ•°å­—ï¼‰ï¼Œå¹¶å°†å¾…æ·»åŠ çš„æ•°å­—æ·»åŠ åˆ°æœ€å°å †ä¸­ã€‚
        // æŒ‰ç…§ä¸Šè¿°è§„åˆ™åœ¨æœ€å°å †ä¸­æ·»åŠ æ•°å­—ï¼Œå°±å¯ä»¥ç¡®ä¿æœ€å°å †ä¸­å…ƒç´ çš„æ•°ç›®ä¸è¶…è¿‡kï¼Œé‡Œé¢ä¿å­˜çš„æ˜¯å‡ºç°é¢‘ç‡æœ€é«˜çš„kä¸ªæ•°å­—ï¼Œå¹¶ä¸”è¿™kä¸ªæ•°å­—ä¸­é¢‘ç‡æœ€ä½çš„æ•°å­—ä½äºå †é¡¶ã€‚
        // ç”¨æœ€å°å †æ¥å­˜å‚¨é¢‘ç‡æœ€é«˜çš„kä¸ªæ•°å­—ã€‚æ³¨æ„å †ä¸­ä¿å­˜çš„æ˜¯æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—åŠå…¶åœ¨æ•°ç»„ä¸­å‡ºç°çš„æ¬¡æ•°ã€‚ä¹Ÿå°±æ˜¯å †ä¸­å…ƒç´ ä¿å­˜çš„æ˜¯å“ˆå¸Œè¡¨ä¸­çš„é”®å€¼å¯¹ã€‚


        ////	è§£æ³•1ï¼šå“ˆå¸Œè¡¨+æœ€å°å †
        //public int[] topKFrequent(int[] nums, int k) {
        //    if (nums == null) {
        //        return null;
        //    }
        //    // å“ˆå¸Œè¡¨å¯ä»¥ç”¨æ¥ç»Ÿè®¡æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„é¢‘ç‡ï¼Œå“ˆå¸Œè¡¨çš„é”®æ˜¯æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—ï¼Œè€Œå€¼æ˜¯æ•°å­—å‡ºç°çš„é¢‘ç‡ã€‚
        //    Map<Integer, Integer> numToCount = new HashMap<>();
        //    for (int num : nums) {// éå†æ•°ç»„å°†æ•°ç»„å…ƒç´ ä¿å­˜åˆ°å“ˆå¸Œè¡¨ä¸­
        //        numToCount.put(num, numToCount.getOrDefault(num, 0) + 1);
        //    }
        //
        //    // æœ€å°å †ä¸­ä¿å­˜å“ˆå¸Œè¡¨çš„é”®å€¼å¯¹Map.Entryã€‚å †ä¸­å…ƒç´ æ ¹æ®é¢‘æ•°æ’åºï¼šè¦å®šä¹‰æ’åºæ–¹å¼ï¼ŒLambdaè¡¨è¾¾å¼å®ç°ã€‚
        //    // javaé»˜è®¤æ˜¯æœ€å°å †ï¼Œå› ä¸ºé”®å€¼å¯¹æ˜¯ä¸¤ä¸ªå…ƒç´ ï¼Œä¸”æ˜¯æŒ‰ç…§é”®å€¼å¯¹å…ƒç´ çš„ç¬¬äºŒä¸ªå…ƒç´ æ¥æ’åºçš„ï¼Œæ‰€ä»¥è¦å®šä¹‰ä¸€ä¸‹æ’åºè§„åˆ™
        //    PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(
        //            (e1, e2) -> e1.getValue() - e2.getValue()// Lambdaè¡¨è¾¾å¼ï¼Œå‡åºæ’åˆ—
        //    );
        //
        //    // éå†å“ˆå¸Œè¡¨ä¸­çš„é”®å€¼å¯¹å…ƒç´ ï¼Œå°†æ»¡è¶³æ¡ä»¶çš„é”®å€¼å¯¹æ·»åŠ åˆ°å †ä¸­
        //    for (Map.Entry<Integer, Integer> entry : numToCount.entrySet()) {
        //        if (minHeap.size() < k) {// å½“å †ä¸­å…ƒç´ æ•°ç›®å°äºkä¸ªï¼Œå°†å½“å‰é”®å€¼å¯¹ç›´æ¥åŠ å…¥å †ä¸­
        //            minHeap.add(entry);
        //        } else {// å½“å †ä¸­å…ƒç´ å·²ç»æœ‰Kä¸ª
        //            if (entry.getValue() > minHeap.peek().getValue()) {// å¦‚æœå½“å‰é”®å€¼å¯¹çš„å€¼å¤§äºå †é¡¶å…ƒç´ é”®å€¼å¯¹çš„å€¼ï¼Œä¹Ÿå°±æ˜¯æ–°éå†å…ƒç´ çš„å‡ºç°æ¬¡æ•°å¤§äºå †é¡¶å…ƒç´ çš„å‡ºç°æ¬¡æ•°
        //                minHeap.poll();// ç§»å‡ºå †é¡¶å…ƒç´ 
        //                minHeap.add(entry);// å°†æ–°çš„é”®å€¼å¯¹å…ƒç´ æ·»åŠ åˆ°å †ä¸­
        //            }
        //        }
        //    }
        //
        //    // å°†å †ä¸­å…ƒç´ çš„é”®ã€å³å‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ã€‘ä¿å­˜åˆ°ç»“æœæ•°ç»„ä¸­
        //    int[] ans = new int[k];
        //    int index = 0;
        //    for (Map.Entry<Integer, Integer> entry : minHeap) {// å¢å¼ºforéå†å“ˆå¸Œè¡¨çš„é”®å€¼å¯¹
        //        ans[index] = entry.getKey();
        //        index++;
        //    }
        //    return ans;
        //}




        ////	è§£æ³•1ï¼šå†™æ³•2 å“ˆå¸Œè¡¨+æœ€å°å †
        //public int[] topKFrequent(int[] nums, int k) {
        //    if (nums == null) {
        //        return null;
        //    }
        //    // å“ˆå¸Œè¡¨å¯ä»¥ç”¨æ¥ç»Ÿè®¡æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„é¢‘ç‡ï¼Œå“ˆå¸Œè¡¨çš„é”®æ˜¯æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—ï¼Œè€Œå€¼æ˜¯æ•°å­—å‡ºç°çš„é¢‘ç‡ã€‚
        //    Map<Integer, Integer> numToCount = new HashMap<>();
        //    for (int num : nums) {// éå†æ•°ç»„å°†æ•°ç»„å…ƒç´ ä¿å­˜åˆ°å“ˆå¸Œè¡¨ä¸­
        //        numToCount.put(num, numToCount.getOrDefault(num, 0) + 1);
        //    }
        //
        //    // æœ€å°å †ä¸­æ¯ä¸€ä¸ªå…ƒç´ ä¿å­˜ä¸¤ä¸ªæ•°æ®ï¼Œåœ¨è¿™é‡Œä½¿ç”¨æ•°ç»„ä¼ é€’å…ƒç´ ã€‚
        //    // è¿™é‡Œä½¿ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿå“ˆå¸Œè¡¨çš„é”®å€¼å¯¹ã€‚int[] çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—ï¼Œç¬¬äºŒä¸ªå…ƒç´ ä»£è¡¨äº†è¯¥æ•°å­—å‡ºç°çš„é¢‘ç‡ã€‚
        //    // å“ˆå¸Œè¡¨çš„é”®æ˜¯æ•°ç»„ä¸­å‡ºç°çš„æ•°å­—ï¼Œè€Œå€¼æ˜¯è¯¥æ•°å­—å‡ºç°çš„é¢‘ç‡ã€‚
        //    PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>(new Comparator<int[]>() {
        //        public int compare(int[] m, int[] n) {
        //            return m[1] - n[1];
        //        }
        //    });
        //
        //
        //    // éå†å“ˆå¸Œè¡¨ä¸­çš„é”®å€¼å¯¹å…ƒç´ ï¼Œå°†æ»¡è¶³æ¡ä»¶çš„é”®å€¼å¯¹æ·»åŠ åˆ°å †ä¸­
        //    for (Map.Entry<Integer, Integer> entry : numToCount.entrySet()) {
        //        if (minHeap.size() < k) {// å½“å †ä¸­å…ƒç´ æ•°ç›®å°äºkä¸ªï¼Œå°†å½“å‰é”®å€¼å¯¹ç›´æ¥åŠ å…¥å †ä¸­
        //            minHeap.add(new int[]{entry.getKey(), entry.getValue()});
        //        } else {// å½“å †ä¸­å…ƒç´ å·²ç»æœ‰Kä¸ª
        //            // minHeap.peek() æ˜¯æœ€å°å †çš„å †é¡¶å…ƒç´ ï¼Œæœ€å°å †çš„å…ƒç´ çš„ç¬¬2ä¸ªå˜é‡æ˜¯è¯¥æ•°å­—å‡ºç°çš„æ¬¡æ•° minHeap.peek()[1]ã€‚
        //            if (entry.getValue() > minHeap.peek()[1]) {// å¦‚æœå½“å‰é”®å€¼å¯¹çš„å€¼å¤§äºå †é¡¶å…ƒç´ é”®å€¼å¯¹çš„å€¼ï¼Œä¹Ÿå°±æ˜¯æ–°éå†å…ƒç´ çš„å‡ºç°æ¬¡æ•°å¤§äºå †é¡¶å…ƒç´ çš„å‡ºç°æ¬¡æ•°
        //                minHeap.poll();// ç§»å‡ºå †é¡¶å…ƒç´ 
        //                minHeap.add(new int[]{entry.getKey(), entry.getValue()});// å°†æ–°çš„é”®å€¼å¯¹å…ƒç´ æ·»åŠ åˆ°å †ä¸­
        //            }
        //        }
        //    }
        //
        //    // å°†å †ä¸­å…ƒç´ çš„é”®ã€å³å‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ã€‘ä¿å­˜åˆ°ç»“æœæ•°ç»„ä¸­
        //    int[] ans = new int[k];
        //    for (int i = 0; i < k; ++i) {
        //        ans[i] = minHeap.poll()[0];
        //    }
        //    return ans;
        //}


        public int[] topKFrequent(int[] nums, int k) {
            if (nums == null || nums.length == 0) {
                return new int[0];
            }
            Map<Integer, Integer> counts = new HashMap<>();
            for (int num : nums) {
                counts.put(num, counts.getOrDefault(num, 0) + 1);
            }
            PriorityQueue<int[]> minHeap = new PriorityQueue<>(k, new Comparator<int[]>() {
                @Override
                public int compare(int[] o1, int[] o2) {
                    return o1[1] - o2[1];
                }
            });

            for(Map.Entry<Integer,Integer> entry:counts.entrySet()){
                if(minHeap.size()<k){
                    minHeap.offer(new int[]{entry.getKey(),entry.getValue()});
                }else {
                    if(entry.getValue()>minHeap.peek()[1]){
                        minHeap.poll();
                        minHeap.offer(new int[]{entry.getKey(),entry.getValue()});
                    }
                }
            }
            int[] ans=new int[k];
            for (int i = 0; i < k; i++) {
                ans[i]=minHeap.poll()[0];
            }
            return ans;
        }



    }
//leetcode submit region end(Prohibit modification and deletion)

}
