/**
<p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 13
<strong>输出：</strong>6
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 0
<strong>输出：</strong>0
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li> 
</ul>

<div><div>Related Topics</div><div><li>递归</li><li>数学</li><li>动态规划</li></div></div><br><div><li>👍 483</li><li>👎 0</li></div>
*/

package leetcode.editor.cn;

/**
 * 233
 * 数字 1 的个数
 * @author wangweizhou
 * @date 2022-12-24 17:46:38
 */
public class NumberOfDigitOne{
	 public static void main(String[] args) {
	 	 //测试代码
	 	 Solution solution = new NumberOfDigitOne().new Solution();
	 }
	 
//leetcode submit region begin(Prohibit modification and deletion)
class Solution {

	// 举个例子： n = 2304 。答案为四个部分之和：
	//1. 所有小于等于2304的正整数中，个位出现1的次数.
	//2. 所有小于等于2304的正整数中，十位出现1的次数.
	//3. 所有小于等于2304的正整数中，百位出现1的次数.
	//4. 所有小于等于2304的正整数中，千位出现1的次数.
	//这四部分可以只考虑一部分，另外三部分就异曲同工了。用第二部分来举例，也就是计算所有小于等于2304的正整数中，十位出现1的次数：
	//为了帮助理解，我们先想象有一个自行车密码锁，一共有四位，每一位可单独滚动。


	// 为了计算十位出现1的次数，我们考虑三种情况：数学归纳法
	//1. n中的十位为0. 即 n = 2304。
	//我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。
	//不难发现，我们能滚出的最大数是：2219,我们能滚出的最小数是：0010。
	//那么0010到2219之间有多少种十位为1的密码呢？我们去掉十位，得到000和229。一共就是229-000+1 = 230种。即n千位和百位构成的数*10。

	//2. n中的十位为1. 即 n = 2314。
	//我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。
	//不难发现，我们能滚出的最大数是：2314,我们能滚出的最小数是：0010。
	//那么0010到2314之间有多少种十位为1的密码呢？我们去掉十位，得到000和234，一共就是234-000+1=23*10+4+1 = 235种。即n千位和百位构成的数*10 + n个位的数字+1.

	//3. n中的十位为2~9中任意数字. 即 n = 2324（只是一个例子，n = 2394是一样的）。
	//我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。
	//不难发现，我们能滚出的最大数是：2319,我们能滚出的最小数是：0010。
	//那么0010到2319之间有多少种十位为1的密码呢？我们去掉十位，得到000和239，一共就是239-000+1 = 240种。也是（23+1）*10 = 240种。即(n万位和千位构成的数*+1)*10.
	//如果我们定义十位左边的数为高位，例如2304的高位为23，十位右边的数为低位，例如2304的低位为4，那么以上规律就可以写成高位和低位的规律。我们分别对2304的每一位做一次分析，并将四部分结果相加就得到了答案。


	// 将 1 ~ n 的个位、十位、百位、...的 1 出现次数相加，即为 1 出现的总次数。
	// cur表示当前位；low表示低位；high表示高位；位因子：digit。

	public int countDigitOne(int n) {
		// 初始化时统计个位上1出现的次数
		int res = 0;
		int digit = 1;// 当前位的位因子：digit，其实就是位权。
		int high = n / 10;// high表示高位，当前位左边的
		int cur = n % 10;// cur表示当前位
		int low = 0;// low表示低位，当前位右边的
		//
		while(high != 0 || cur != 0) {
			if(cur == 0) {// 当前位是0
				res += high * digit;
			} else if(cur == 1) {// 当前位是1
				res += high * digit + low + 1;
			} else {// 当前位是2~9
				res += (high + 1) * digit;
			}
			// 上面执行完了，当前位向右移动，这时候低位和高位伴随变换，注意后面的先后顺序
			low += cur * digit;
			cur = high % 10;
			high /= 10;
			digit *= 10;
		}
		return res;
	}



}
//leetcode submit region end(Prohibit modification and deletion)

}
